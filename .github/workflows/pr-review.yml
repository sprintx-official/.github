# =============================================================================
# ORGANIZATION REUSABLE WORKFLOW - AI PR Review (Senior Developer Level)
# =============================================================================
# Intelligent code review that understands your project context, detects
# code reuse opportunities, and reviews like a senior developer would.
#
# Individual repos can call this workflow with just a few lines:
#
# jobs:
#   review:
#     uses: sprintx-official/.github/.github/workflows/pr-review.yml@main
#     secrets: inherit
# =============================================================================

name: AI PR Review (Reusable)

on:
  workflow_call:
    inputs:
      conventions_path:
        description: 'Path to conventions file'
        required: false
        type: string
        default: '.planning/CONVENTIONS.md'
      project_standards_path:
        description: 'Path to project standards file'
        required: false
        type: string
        default: '.planning/PROJECT.md'
      project_docs_path:
        description: 'Path to project documentation (idea, features, requirements)'
        required: false
        type: string
        default: 'docs/PROJECT.md'
      model:
        description: 'Gemini model to use'
        required: false
        type: string
        default: 'gemini-2.0-flash'
      max_diff_size:
        description: 'Maximum diff size to send to AI (in characters)'
        required: false
        type: number
        default: 50000
      scan_patterns:
        description: 'JSON array of glob patterns to scan for existing code (e.g., ["src/components/**/*.tsx", "src/utils/**/*.ts"])'
        required: false
        type: string
        default: '["src/components/**/*", "src/lib/**/*", "src/utils/**/*", "src/helpers/**/*", "src/hooks/**/*", "src/constants/**/*", "src/shared/**/*", "lib/**/*", "utils/**/*", "common/**/*"]'
    secrets:
      GEMINI_API_KEY:
        required: true

permissions:
  contents: read
  pull-requests: write

jobs:
  ai-review:
    runs-on: ubuntu-latest
    name: Gemini PR Review

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get PR diff
        id: diff
        run: |
          git diff origin/${{ github.base_ref }}...origin/${{ github.head_ref }} > pr_diff.txt
          git diff --name-only origin/${{ github.base_ref }}...origin/${{ github.head_ref }} > changed_files.txt
          echo "Changed files:"
          cat changed_files.txt

      - name: Read project files
        run: |
          # Read conventions
          if [ -f "${{ inputs.conventions_path }}" ]; then
            cat "${{ inputs.conventions_path }}" > conventions_content.txt
          else
            echo "No conventions file found" > conventions_content.txt
          fi

          # Read project standards
          if [ -f "${{ inputs.project_standards_path }}" ]; then
            cat "${{ inputs.project_standards_path }}" > standards_content.txt
          else
            echo "No project standards file found" > standards_content.txt
          fi

          # Read project documentation (idea, features, requirements)
          if [ -f "${{ inputs.project_docs_path }}" ]; then
            cat "${{ inputs.project_docs_path }}" > project_docs_content.txt
          else
            echo "No project documentation file found" > project_docs_content.txt
          fi

      - name: Scan existing codebase for reusable patterns
        run: |
          echo "=== EXISTING CODEBASE ANALYSIS ===" > codebase_context.txt
          echo "" >> codebase_context.txt

          # Parse scan patterns from input
          PATTERNS='${{ inputs.scan_patterns }}'

          # Find and list all existing components, utils, helpers, hooks, constants
          echo "### Existing Reusable Code Files ###" >> codebase_context.txt
          echo "These are files that contain potentially reusable code. Check if the PR duplicates any of these." >> codebase_context.txt
          echo "" >> codebase_context.txt

          # Find files matching patterns and extract their exports/definitions
          for pattern in $(echo "$PATTERNS" | jq -r '.[]' 2>/dev/null || echo "src/components src/utils src/lib src/helpers src/hooks src/constants"); do
            if ls $pattern 2>/dev/null | head -1 > /dev/null; then
              echo "#### Pattern: $pattern ####" >> codebase_context.txt
              find . -path "./$pattern" -type f \( -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" \) 2>/dev/null | head -100 | while read file; do
                if [ -f "$file" ]; then
                  echo "" >> codebase_context.txt
                  echo "**File: $file**" >> codebase_context.txt
                  # Extract exports, function names, component names, constants
                  grep -E "^export (const|function|class|interface|type|enum|default)" "$file" 2>/dev/null | head -20 >> codebase_context.txt || true
                  grep -E "^(const|let|var) [A-Z][A-Z_]+ =" "$file" 2>/dev/null | head -10 >> codebase_context.txt || true
                fi
              done
              echo "" >> codebase_context.txt
            fi
          done

          # Analyze common patterns in the codebase
          echo "" >> codebase_context.txt
          echo "### Common Patterns Detected ###" >> codebase_context.txt

          # Find commonly used custom hooks
          echo "" >> codebase_context.txt
          echo "#### Custom Hooks Available ####" >> codebase_context.txt
          find . -type f -name "use*.ts" -o -name "use*.tsx" 2>/dev/null | grep -v node_modules | grep -v ".next" | head -30 >> codebase_context.txt || echo "None found" >> codebase_context.txt

          # Find utility functions
          echo "" >> codebase_context.txt
          echo "#### Utility Files ####" >> codebase_context.txt
          find . -type f \( -path "*/utils/*" -o -path "*/helpers/*" -o -path "*/lib/*" \) \( -name "*.ts" -o -name "*.js" \) 2>/dev/null | grep -v node_modules | grep -v ".next" | head -30 >> codebase_context.txt || echo "None found" >> codebase_context.txt

          # Find constants files
          echo "" >> codebase_context.txt
          echo "#### Constants Files ####" >> codebase_context.txt
          find . -type f \( -path "*/constants/*" -o -name "constants.ts" -o -name "constants.js" -o -name "config.ts" -o -name "config.js" \) 2>/dev/null | grep -v node_modules | grep -v ".next" | head -20 >> codebase_context.txt || echo "None found" >> codebase_context.txt

          # Find shared/common components
          echo "" >> codebase_context.txt
          echo "#### Shared/Common Components ####" >> codebase_context.txt
          find . -type f \( -path "*/components/common/*" -o -path "*/components/shared/*" -o -path "*/components/ui/*" \) \( -name "*.tsx" -o -name "*.jsx" \) 2>/dev/null | grep -v node_modules | grep -v ".next" | head -30 >> codebase_context.txt || echo "None found" >> codebase_context.txt

          # Truncate if too large
          if [ $(wc -c < codebase_context.txt) -gt 30000 ]; then
            head -c 30000 codebase_context.txt > codebase_context_truncated.txt
            mv codebase_context_truncated.txt codebase_context.txt
            echo "" >> codebase_context.txt
            echo "... (truncated for size)" >> codebase_context.txt
          fi

          echo "Codebase context generated successfully"
          cat codebase_context.txt

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Create review script
        run: |
          cat > review_script.js << 'SCRIPT_EOF'
          const fs = require('fs');
          const https = require('https');

          const maxDiffSize = parseInt(process.env.MAX_DIFF_SIZE || '50000');
          const diff = fs.readFileSync('pr_diff.txt', 'utf8').slice(0, maxDiffSize);
          const changedFiles = fs.readFileSync('changed_files.txt', 'utf8');
          const conventions = fs.readFileSync('conventions_content.txt', 'utf8');
          const standards = fs.readFileSync('standards_content.txt', 'utf8');
          const projectDocs = fs.readFileSync('project_docs_content.txt', 'utf8');
          const codebaseContext = fs.readFileSync('codebase_context.txt', 'utf8');
          const prTitle = process.env.PR_TITLE || 'No title';
          const prBody = process.env.PR_BODY || 'No description';
          const model = process.env.GEMINI_MODEL || 'gemini-2.0-flash';

          const prompt = `You are a SENIOR STAFF ENGINEER conducting a thorough code review. You have deep expertise in software architecture, design patterns, and have seen many codebases evolve over years. You understand the long-term implications of code decisions.

          Your review philosophy:
          - Code should be written for the NEXT developer to read, not just to work
          - Every line of code is a liability - less code is better
          - Duplication is cheaper than the wrong abstraction, but obvious duplication should be avoided
          - Think about what happens when this code needs to change in 6 months
          - Consider: "Would I be comfortable if this ran in production at 3 AM and I had to debug it?"

          ---

          # PROJECT CONTEXT

          ## Project Overview & Requirements
          Read this carefully to understand what this project is trying to achieve. The PR should align with these goals.

          ${projectDocs}

          ## Technical Standards & Architecture
          The technical decisions and patterns established for this project.

          ${standards}

          ## Coding Conventions
          The rules the team has agreed to follow.

          ${conventions}

          ---

          # EXISTING CODEBASE ANALYSIS

          CRITICAL: Review this section carefully. The developer may have created something that ALREADY EXISTS in the codebase. This is one of the most common issues in PRs.

          ${codebaseContext}

          ---

          # PULL REQUEST DETAILS

          **Title:** ${prTitle}
          **Description:** ${prBody}

          ## Changed Files
          ${changedFiles}

          ## Code Diff
          \`\`\`diff
          ${diff}
          \`\`\`

          ---

          # SENIOR DEVELOPER REVIEW CHECKLIST

          ## 1. ðŸ”„ CODE REUSE & DUPLICATION (HIGHEST PRIORITY)
          This is where junior/mid developers make the most mistakes. Check carefully:

          - **Existing utilities ignored**: Is the developer writing code that already exists in utils/, helpers/, or lib/?
          - **Existing components ignored**: Are they creating a new component when a similar one exists in components/common/ or components/shared/?
          - **Existing hooks ignored**: Are they reimplementing logic that an existing custom hook provides?
          - **Existing constants ignored**: Are they hardcoding values that should come from constants/?
          - **Copy-paste code**: Is there code that looks copy-pasted from another file without proper abstraction?
          - **New common logic not extracted**: Is the developer adding code that SHOULD be a shared utility/component but isn't?

          Ask yourself: "Have I seen this pattern elsewhere in this codebase? Should this be shared?"

          ## 2. ðŸ—ï¸ ARCHITECTURAL CONCERNS
          Think about the long-term health of the codebase:

          - **Coupling**: Is this code tightly coupled to things it shouldn't be?
          - **Wrong layer**: Is business logic in UI components? Is UI logic in services?
          - **Scalability**: Will this approach work when we have 10x more data/users?
          - **Testability**: Can this code be unit tested? Is it structured for testing?
          - **State management**: Is state being managed at the right level?
          - **Data flow**: Is the data flow clear and predictable?

          ## 3. âš ï¸ FUTURE PROBLEMS (Things that will bite us later)

          - **Magic numbers/strings**: Are there hardcoded values that should be constants?
          - **Implicit dependencies**: Does this code rely on things that aren't explicit?
          - **Fragile patterns**: Will this break if we change something seemingly unrelated?
          - **Missing error states**: What happens when this fails? Is failure handled gracefully?
          - **Edge cases**: Are edge cases handled? Empty arrays, null values, network failures?
          - **Race conditions**: In async code, are there potential race conditions?
          - **Memory leaks**: Are event listeners cleaned up? Are subscriptions unsubscribed?

          ## 4. ðŸ“– CODE QUALITY & READABILITY

          - **Naming**: Do names clearly describe what things do? Would you understand this in 6 months?
          - **Complexity**: Is there unnecessary complexity? Could this be simpler?
          - **Comments**: Are complex parts explained? Are there misleading comments?
          - **Function length**: Are functions doing too much? Should they be split?
          - **Type safety**: Are types properly defined? Any 'any' types that should be specific?

          ## 5. ðŸ”’ SECURITY

          - **Injection risks**: SQL injection, XSS, command injection
          - **Authentication/Authorization**: Is access properly controlled?
          - **Sensitive data**: Are secrets, tokens, or PII properly handled?
          - **Input validation**: Is user input validated before use?

          ## 6. âš¡ PERFORMANCE

          - **Unnecessary work**: Are there computations that could be avoided or memoized?
          - **Re-renders**: In React, are there unnecessary re-renders?
          - **Bundle size**: Are large dependencies being imported unnecessarily?
          - **Database/API**: Are there N+1 queries or excessive API calls?

          ## 7. âœ… PROJECT ALIGNMENT

          - Does this PR actually solve the problem it claims to solve?
          - Is this the right approach given the project's goals?
          - Are there any missing pieces that should be included?

          ---

          # OUTPUT FORMAT

          ## PART 1: Inline Comments (JSON)
          Provide a JSON array of specific, actionable comments:

          \`\`\`json
          [
            {
              "file": "path/to/file.tsx",
              "line": 10,
              "severity": "critical|warning|suggestion",
              "category": "reuse|architecture|future-problem|quality|security|performance|alignment",
              "comment": "Specific issue and how to fix it. If suggesting to use existing code, mention the specific file/function."
            }
          ]
          \`\`\`

          **Severity Guide:**
          - **critical**: Must fix before merge. Security issues, bugs, or code that will definitely cause problems.
          - **warning**: Should fix. Code smells, missing patterns, or things that will likely cause issues.
          - **suggestion**: Nice to have. Improvements that would make the code better but aren't blocking.

          **Category Guide:**
          - **reuse**: Could use existing code, or should extract to shared location
          - **architecture**: Design or structural issues
          - **future-problem**: Will cause problems later
          - **quality**: Readability, naming, complexity
          - **security**: Security vulnerabilities
          - **performance**: Performance issues
          - **alignment**: Doesn't match project goals

          **Rules:**
          - "line" = line number in the NEW file (from the + lines in diff)
          - Only comment on ADDED lines (lines starting with +)
          - Be specific: Instead of "use a constant", say "This should use API_BASE_URL from src/constants/api.ts"
          - Focus on the most important issues first

          ## PART 2: Summary
          After the JSON, provide a brief summary:

          ### Overall Assessment
          One line: Is this PR ready to merge, needs minor fixes, or needs significant work?

          ### Code Reuse Analysis
          Did the developer reuse existing code appropriately? Did they miss opportunities to use existing utilities/components?

          ### Architectural Impact
          Does this PR maintain or improve the codebase architecture? Any concerns?

          ### What's Done Well
          Genuine positives (not empty praise)

          ### Key Action Items
          The 2-3 most important things to address before merging

          IMPORTANT: Start with the JSON array, then the summary. Be direct and specific - vague feedback is useless.`;

          const requestBody = JSON.stringify({
            contents: [{ parts: [{ text: prompt }] }],
            generationConfig: {
              temperature: 0.3,
              topK: 40,
              topP: 0.95,
              maxOutputTokens: 8192
            }
          });

          const options = {
            hostname: 'generativelanguage.googleapis.com',
            path: `/v1beta/models/${model}:generateContent?key=${process.env.GEMINI_API_KEY}`,
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Content-Length': Buffer.byteLength(requestBody)
            }
          };

          const req = https.request(options, (res) => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
              try {
                const json = JSON.parse(data);
                if (json.candidates && json.candidates[0] && json.candidates[0].content) {
                  fs.writeFileSync('review_output.txt', json.candidates[0].content.parts[0].text);
                  console.log('Review generated successfully');
                } else if (json.error) {
                  fs.writeFileSync('review_output.txt', 'API Error: ' + json.error.message);
                  console.error('API Error:', json.error.message);
                } else {
                  fs.writeFileSync('review_output.txt', 'Unexpected response format from Gemini API');
                  console.error('Unexpected response:', data);
                }
              } catch (e) {
                fs.writeFileSync('review_output.txt', 'Parse error: ' + e.message);
                console.error('Parse error:', e.message);
              }
            });
          });

          req.on('error', (e) => {
            fs.writeFileSync('review_output.txt', 'Request error: ' + e.message);
            console.error('Request error:', e.message);
          });

          req.write(requestBody);
          req.end();
          SCRIPT_EOF

      - name: Run Gemini PR Review
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_BODY: ${{ github.event.pull_request.body }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          GEMINI_MODEL: ${{ inputs.model }}
          MAX_DIFF_SIZE: ${{ inputs.max_diff_size }}
        run: node review_script.js

      - name: Post review with inline comments
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const reviewOutput = fs.readFileSync('review_output.txt', 'utf8');

            let inlineComments = [];
            let summary = reviewOutput;

            try {
              const jsonMatch = reviewOutput.match(/```json\n?([\s\S]*?)\n?```/);
              if (jsonMatch) {
                inlineComments = JSON.parse(jsonMatch[1]);
                summary = reviewOutput.replace(/```json\n?[\s\S]*?\n?```/, '').trim();
              } else {
                const arrayMatch = reviewOutput.match(/\[\s*\{[\s\S]*?\}\s*\]/);
                if (arrayMatch) {
                  inlineComments = JSON.parse(arrayMatch[0]);
                  summary = reviewOutput.replace(arrayMatch[0], '').trim();
                }
              }
            } catch (e) {
              console.log('Could not parse inline comments:', e.message);
            }

            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            const filePatches = {};
            for (const file of files) {
              filePatches[file.filename] = file.patch || '';
            }

            function findDiffPosition(filename, targetLine) {
              const patch = filePatches[filename];
              if (!patch) return null;

              const lines = patch.split('\n');
              let currentLine = 0;
              let position = 0;

              for (const line of lines) {
                position++;
                const hunkMatch = line.match(/@@ -\d+(?:,\d+)? \+(\d+)(?:,\d+)? @@/);
                if (hunkMatch) {
                  currentLine = parseInt(hunkMatch[1]) - 1;
                  continue;
                }
                if (line.startsWith('-')) {
                  continue;
                }
                if (line.startsWith('+') || !line.startsWith('-')) {
                  currentLine++;
                  if (currentLine === targetLine) {
                    return position;
                  }
                }
              }
              return null;
            }

            const reviewComments = [];
            const severityEmoji = { critical: 'ðŸ”´', warning: 'ðŸŸ ', suggestion: 'ðŸŸ¡' };
            const categoryEmoji = {
              'reuse': 'â™»ï¸',
              'architecture': 'ðŸ—ï¸',
              'future-problem': 'âš ï¸',
              'quality': 'ðŸ“–',
              'security': 'ðŸ”’',
              'performance': 'âš¡',
              'alignment': 'ðŸŽ¯'
            };
            const categoryLabel = {
              'reuse': 'Code Reuse',
              'architecture': 'Architecture',
              'future-problem': 'Future Problem',
              'quality': 'Code Quality',
              'security': 'Security',
              'performance': 'Performance',
              'alignment': 'Project Alignment'
            };

            for (const comment of inlineComments) {
              const position = findDiffPosition(comment.file, comment.line);
              if (position && filePatches[comment.file]) {
                const sevEmoji = severityEmoji[comment.severity] || 'ðŸ’¬';
                const catEmoji = categoryEmoji[comment.category] || '';
                const catLabel = categoryLabel[comment.category] || '';
                const categoryTag = catLabel ? ` \`${catLabel}\`` : '';

                reviewComments.push({
                  path: comment.file,
                  position: position,
                  body: `${sevEmoji} **${(comment.severity || 'comment').toUpperCase()}**${categoryTag}\n\n${catEmoji} ${comment.comment}`
                });
              }
            }

            // Count issues by category for summary
            const categoryCounts = {};
            for (const comment of inlineComments) {
              const cat = comment.category || 'other';
              categoryCounts[cat] = (categoryCounts[cat] || 0) + 1;
            }

            const hasCritical = inlineComments.some(c => c.severity === 'critical');
            const hasWarning = inlineComments.some(c => c.severity === 'warning');
            const reviewEvent = hasCritical ? 'REQUEST_CHANGES' : 'COMMENT';

            // Build category breakdown
            let categoryBreakdown = '';
            if (Object.keys(categoryCounts).length > 0) {
              categoryBreakdown = '\n\n**Issues by Category:**\n';
              for (const [cat, count] of Object.entries(categoryCounts)) {
                const emoji = categoryEmoji[cat] || 'ðŸ“';
                const label = categoryLabel[cat] || cat;
                categoryBreakdown += `- ${emoji} ${label}: ${count}\n`;
              }
            }

            const summaryBody = `## ðŸ¤– Senior Developer AI Review\n\n${summary}\n${categoryBreakdown}\n---\n*Reviewed as a senior developer by Gemini AI â€¢ ${reviewComments.length} inline comments â€¢ ${hasCritical ? 'ðŸ”´ Has critical issues' : hasWarning ? 'ðŸŸ  Has warnings' : 'âœ… Looks good'}*`;

            try {
              if (reviewComments.length > 0) {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  body: summaryBody,
                  event: reviewEvent,
                  comments: reviewComments
                });
                console.log('Created review with ' + reviewComments.length + ' inline comments');
              } else {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  body: summaryBody,
                  event: 'COMMENT'
                });
                console.log('Created review without inline comments');
              }
            } catch (error) {
              console.error('Error creating review:', error.message);
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: summaryBody
              });
            }
