# =============================================================================
# ORGANIZATION REUSABLE WORKFLOW - AI PR Review
# =============================================================================
# Individual repos can call this workflow with just a few lines:
#
# jobs:
#   review:
#     uses: sprintx-official/.github/.github/workflows/pr-review.yml@main
#     secrets: inherit
# =============================================================================

name: AI PR Review (Reusable)

on:
  workflow_call:
    inputs:
      conventions_path:
        description: 'Path to conventions file'
        required: false
        type: string
        default: '.planning/CONVENTIONS.md'
      project_path:
        description: 'Path to project standards file'
        required: false
        type: string
        default: '.planning/PROJECT.md'
      model:
        description: 'Gemini model to use'
        required: false
        type: string
        default: 'gemini-2.0-flash'
    secrets:
      GEMINI_API_KEY:
        required: true

permissions:
  contents: read
  pull-requests: write

jobs:
  ai-review:
    runs-on: ubuntu-latest
    name: Gemini PR Review

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get PR diff
        id: diff
        run: |
          git diff origin/${{ github.base_ref }}...origin/${{ github.head_ref }} > pr_diff.txt
          git diff --name-only origin/${{ github.base_ref }}...origin/${{ github.head_ref }} > changed_files.txt
          echo "Changed files:"
          cat changed_files.txt

      - name: Read project conventions
        id: conventions
        run: |
          if [ -f "${{ inputs.conventions_path }}" ]; then
            cat "${{ inputs.conventions_path }}" > conventions_content.txt
          else
            echo "No conventions file found at ${{ inputs.conventions_path }}" > conventions_content.txt
          fi

          if [ -f "${{ inputs.project_path }}" ]; then
            cat "${{ inputs.project_path }}" > project_content.txt
          else
            echo "No project file found at ${{ inputs.project_path }}" > project_content.txt
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Run Gemini PR Review
        id: review
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_BODY: ${{ github.event.pull_request.body }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          GEMINI_MODEL: ${{ inputs.model }}
        run: |
          node << 'NODE_EOF'
          const fs = require('fs');
          const https = require('https');

          const diff = fs.readFileSync('pr_diff.txt', 'utf8').slice(0, 30000);
          const changedFiles = fs.readFileSync('changed_files.txt', 'utf8');
          const conventions = fs.readFileSync('conventions_content.txt', 'utf8');
          const project = fs.readFileSync('project_content.txt', 'utf8');
          const prTitle = process.env.PR_TITLE || 'No title';
          const prBody = process.env.PR_BODY || 'No description';
          const model = process.env.GEMINI_MODEL || 'gemini-2.0-flash';

          const prompt = `You are an expert code reviewer. Review the following PR diff against the project standards and conventions.

## Project Standards

${project}

## Coding Conventions

${conventions}

## PR Information

**Title:** ${prTitle}
**Description:** ${prBody}

## Changed Files

${changedFiles}

## Code Diff

\`\`\`diff
${diff}
\`\`\`

## Review Instructions

Analyze the code and provide your review in TWO parts:

### PART 1: Inline Comments (JSON)
Return a JSON array of inline comments for specific lines. Each comment should target a specific line in the diff.
IMPORTANT: Only comment on lines that were ADDED (lines starting with +) in the diff.

Format:
\`\`\`json
[
  {
    "file": "path/to/file.tsx",
    "line": 10,
    "severity": "critical|warning|suggestion",
    "comment": "Brief description of the issue and how to fix it"
  }
]
\`\`\`

Rules for inline comments:
- "line" must be the line number in the NEW file (after changes), not the diff line number
- Only include actionable feedback
- Keep comments concise (1-2 sentences)
- Focus on: convention violations, bugs, security issues, performance problems
- severity: "critical" = must fix, "warning" = should fix, "suggestion" = nice to have

### PART 2: Summary
After the JSON, provide a brief overall summary:
- Overall assessment (1-2 sentences)
- What's done well
- Key recommendations

IMPORTANT: Start your response with the JSON array, then add the summary after.`;

          const requestBody = JSON.stringify({
            contents: [{ parts: [{ text: prompt }] }],
            generationConfig: {
              temperature: 0.3,
              topK: 40,
              topP: 0.95,
              maxOutputTokens: 8192
            }
          });

          const options = {
            hostname: 'generativelanguage.googleapis.com',
            path: `/v1beta/models/${model}:generateContent?key=${process.env.GEMINI_API_KEY}`,
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Content-Length': Buffer.byteLength(requestBody)
            }
          };

          const req = https.request(options, (res) => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
              try {
                const json = JSON.parse(data);
                if (json.candidates?.[0]?.content?.parts?.[0]?.text) {
                  fs.writeFileSync('review_output.txt', json.candidates[0].content.parts[0].text);
                  console.log('Review generated successfully');
                } else if (json.error) {
                  fs.writeFileSync('review_output.txt', `API Error: ${json.error.message}`);
                  console.error('API Error:', json.error.message);
                } else {
                  fs.writeFileSync('review_output.txt', 'Unexpected response format from Gemini API');
                  console.error('Unexpected response:', data);
                }
              } catch (e) {
                fs.writeFileSync('review_output.txt', `Parse error: ${e.message}`);
                console.error('Parse error:', e.message);
              }
            });
          });

          req.on('error', (e) => {
            fs.writeFileSync('review_output.txt', `Request error: ${e.message}`);
            console.error('Request error:', e.message);
          });

          req.write(requestBody);
          req.end();
          NODE_EOF

      - name: Post review with inline comments
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
        with:
          script: |
            const fs = require('fs');
            const reviewOutput = fs.readFileSync('review_output.txt', 'utf8');

            // Parse inline comments from JSON
            let inlineComments = [];
            let summary = reviewOutput;

            try {
              // Extract JSON array from response
              const jsonMatch = reviewOutput.match(/```json\n?([\s\S]*?)\n?```/);
              if (jsonMatch) {
                inlineComments = JSON.parse(jsonMatch[1]);
                summary = reviewOutput.replace(/```json\n?[\s\S]*?\n?```/, '').trim();
              } else {
                // Try to find JSON array directly
                const arrayMatch = reviewOutput.match(/\[\s*\{[\s\S]*?\}\s*\]/);
                if (arrayMatch) {
                  inlineComments = JSON.parse(arrayMatch[0]);
                  summary = reviewOutput.replace(arrayMatch[0], '').trim();
                }
              }
            } catch (e) {
              console.log('Could not parse inline comments:', e.message);
            }

            // Get the PR diff to map file positions
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            // Create a map of file patches for line position calculation
            const filePatches = {};
            for (const file of files) {
              filePatches[file.filename] = file.patch || '';
            }

            // Function to find position in diff for a given line
            function findDiffPosition(filename, targetLine) {
              const patch = filePatches[filename];
              if (!patch) return null;

              const lines = patch.split('\n');
              let currentLine = 0;
              let position = 0;

              for (const line of lines) {
                position++;

                // Parse hunk header: @@ -start,count +start,count @@
                const hunkMatch = line.match(/@@ -\d+(?:,\d+)? \+(\d+)(?:,\d+)? @@/);
                if (hunkMatch) {
                  currentLine = parseInt(hunkMatch[1]) - 1;
                  continue;
                }

                // Skip removed lines (they don't exist in new file)
                if (line.startsWith('-')) {
                  continue;
                }

                // Count added and context lines
                if (line.startsWith('+') || !line.startsWith('-')) {
                  currentLine++;
                  if (currentLine === targetLine) {
                    return position;
                  }
                }
              }
              return null;
            }

            // Build review comments array
            const reviewComments = [];
            const severityEmoji = {
              critical: 'ðŸ”´',
              warning: 'ðŸŸ ',
              suggestion: 'ðŸŸ¡'
            };

            for (const comment of inlineComments) {
              const position = findDiffPosition(comment.file, comment.line);
              if (position && filePatches[comment.file]) {
                const emoji = severityEmoji[comment.severity] || 'ðŸ’¬';
                reviewComments.push({
                  path: comment.file,
                  position: position,
                  body: `${emoji} **${comment.severity?.toUpperCase() || 'COMMENT'}**\n\n${comment.comment}`
                });
              }
            }

            // Determine review event based on issues found
            const hasCritical = inlineComments.some(c => c.severity === 'critical');
            const reviewEvent = hasCritical ? 'REQUEST_CHANGES' : 'COMMENT';

            // Create the review with inline comments
            const summaryBody = `## ðŸ¤– AI Code Review

${summary}

---
*Automated review powered by Gemini AI â€¢ ${reviewComments.length} inline comments added*`;

            try {
              if (reviewComments.length > 0) {
                // Submit as a proper PR review with inline comments
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  body: summaryBody,
                  event: reviewEvent,
                  comments: reviewComments
                });
                console.log(`Created review with ${reviewComments.length} inline comments`);
              } else {
                // No inline comments, just post summary
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  body: summaryBody,
                  event: 'COMMENT'
                });
                console.log('Created review without inline comments');
              }
            } catch (error) {
              console.error('Error creating review:', error.message);
              // Fallback to regular comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: summaryBody
              });
            }
