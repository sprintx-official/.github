# =============================================================================
# ORGANIZATION REUSABLE WORKFLOW - AI PR Review
# =============================================================================
# Individual repos can call this workflow with just a few lines:
#
# jobs:
#   review:
#     uses: sprintx-official/.github/.github/workflows/pr-review.yml@main
#     secrets: inherit
# =============================================================================

name: AI PR Review (Reusable)

on:
  workflow_call:
    inputs:
      conventions_path:
        description: 'Path to conventions file'
        required: false
        type: string
        default: '.planning/CONVENTIONS.md'
      project_path:
        description: 'Path to project standards file'
        required: false
        type: string
        default: '.planning/PROJECT.md'
      model:
        description: 'Gemini model to use'
        required: false
        type: string
        default: 'gemini-2.0-flash'
    secrets:
      GEMINI_API_KEY:
        required: true

permissions:
  contents: read
  pull-requests: write

jobs:
  ai-review:
    runs-on: ubuntu-latest
    name: Gemini PR Review

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get PR diff
        id: diff
        run: |
          git diff origin/${{ github.base_ref }}...origin/${{ github.head_ref }} > pr_diff.txt
          git diff --name-only origin/${{ github.base_ref }}...origin/${{ github.head_ref }} > changed_files.txt
          echo "Changed files:"
          cat changed_files.txt

      - name: Read project conventions
        id: conventions
        run: |
          if [ -f "${{ inputs.conventions_path }}" ]; then
            cat "${{ inputs.conventions_path }}" > conventions_content.txt
          else
            echo "No conventions file found at ${{ inputs.conventions_path }}" > conventions_content.txt
          fi

          if [ -f "${{ inputs.project_path }}" ]; then
            cat "${{ inputs.project_path }}" > project_content.txt
          else
            echo "No project file found at ${{ inputs.project_path }}" > project_content.txt
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Create review script
        run: |
          cat > review_script.js << 'SCRIPT_EOF'
          const fs = require('fs');
          const https = require('https');

          const diff = fs.readFileSync('pr_diff.txt', 'utf8').slice(0, 30000);
          const changedFiles = fs.readFileSync('changed_files.txt', 'utf8');
          const conventions = fs.readFileSync('conventions_content.txt', 'utf8');
          const project = fs.readFileSync('project_content.txt', 'utf8');
          const prTitle = process.env.PR_TITLE || 'No title';
          const prBody = process.env.PR_BODY || 'No description';
          const model = process.env.GEMINI_MODEL || 'gemini-2.0-flash';

          const prompt = `You are an expert code reviewer. Review the following PR diff against the project standards and conventions.

          ## Project Standards

          ${project}

          ## Coding Conventions

          ${conventions}

          ## PR Information

          **Title:** ${prTitle}
          **Description:** ${prBody}

          ## Changed Files

          ${changedFiles}

          ## Code Diff

          \`\`\`diff
          ${diff}
          \`\`\`

          ## Review Instructions

          Analyze the code and provide your review in TWO parts:

          ### PART 1: Inline Comments (JSON)
          Return a JSON array of inline comments for specific lines. Each comment should target a specific line in the diff.
          IMPORTANT: Only comment on lines that were ADDED (lines starting with +) in the diff.

          Format:
          \`\`\`json
          [
            {
              "file": "path/to/file.tsx",
              "line": 10,
              "severity": "critical|warning|suggestion",
              "comment": "Brief description of the issue and how to fix it"
            }
          ]
          \`\`\`

          Rules for inline comments:
          - "line" must be the line number in the NEW file (after changes), not the diff line number
          - Only include actionable feedback
          - Keep comments concise (1-2 sentences)
          - Focus on: convention violations, bugs, security issues, performance problems
          - severity: "critical" = must fix, "warning" = should fix, "suggestion" = nice to have

          ### PART 2: Summary
          After the JSON, provide a brief overall summary:
          - Overall assessment (1-2 sentences)
          - What's done well
          - Key recommendations

          IMPORTANT: Start your response with the JSON array, then add the summary after.`;

          const requestBody = JSON.stringify({
            contents: [{ parts: [{ text: prompt }] }],
            generationConfig: {
              temperature: 0.3,
              topK: 40,
              topP: 0.95,
              maxOutputTokens: 8192
            }
          });

          const options = {
            hostname: 'generativelanguage.googleapis.com',
            path: `/v1beta/models/${model}:generateContent?key=${process.env.GEMINI_API_KEY}`,
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Content-Length': Buffer.byteLength(requestBody)
            }
          };

          const req = https.request(options, (res) => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
              try {
                const json = JSON.parse(data);
                if (json.candidates && json.candidates[0] && json.candidates[0].content) {
                  fs.writeFileSync('review_output.txt', json.candidates[0].content.parts[0].text);
                  console.log('Review generated successfully');
                } else if (json.error) {
                  fs.writeFileSync('review_output.txt', 'API Error: ' + json.error.message);
                  console.error('API Error:', json.error.message);
                } else {
                  fs.writeFileSync('review_output.txt', 'Unexpected response format from Gemini API');
                  console.error('Unexpected response:', data);
                }
              } catch (e) {
                fs.writeFileSync('review_output.txt', 'Parse error: ' + e.message);
                console.error('Parse error:', e.message);
              }
            });
          });

          req.on('error', (e) => {
            fs.writeFileSync('review_output.txt', 'Request error: ' + e.message);
            console.error('Request error:', e.message);
          });

          req.write(requestBody);
          req.end();
          SCRIPT_EOF

      - name: Run Gemini PR Review
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_BODY: ${{ github.event.pull_request.body }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          GEMINI_MODEL: ${{ inputs.model }}
        run: node review_script.js

      - name: Post review with inline comments
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const reviewOutput = fs.readFileSync('review_output.txt', 'utf8');

            let inlineComments = [];
            let summary = reviewOutput;

            try {
              const jsonMatch = reviewOutput.match(/```json\n?([\s\S]*?)\n?```/);
              if (jsonMatch) {
                inlineComments = JSON.parse(jsonMatch[1]);
                summary = reviewOutput.replace(/```json\n?[\s\S]*?\n?```/, '').trim();
              } else {
                const arrayMatch = reviewOutput.match(/\[\s*\{[\s\S]*?\}\s*\]/);
                if (arrayMatch) {
                  inlineComments = JSON.parse(arrayMatch[0]);
                  summary = reviewOutput.replace(arrayMatch[0], '').trim();
                }
              }
            } catch (e) {
              console.log('Could not parse inline comments:', e.message);
            }

            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            const filePatches = {};
            for (const file of files) {
              filePatches[file.filename] = file.patch || '';
            }

            function findDiffPosition(filename, targetLine) {
              const patch = filePatches[filename];
              if (!patch) return null;

              const lines = patch.split('\n');
              let currentLine = 0;
              let position = 0;

              for (const line of lines) {
                position++;
                const hunkMatch = line.match(/@@ -\d+(?:,\d+)? \+(\d+)(?:,\d+)? @@/);
                if (hunkMatch) {
                  currentLine = parseInt(hunkMatch[1]) - 1;
                  continue;
                }
                if (line.startsWith('-')) {
                  continue;
                }
                if (line.startsWith('+') || !line.startsWith('-')) {
                  currentLine++;
                  if (currentLine === targetLine) {
                    return position;
                  }
                }
              }
              return null;
            }

            const reviewComments = [];
            const severityEmoji = { critical: 'ðŸ”´', warning: 'ðŸŸ ', suggestion: 'ðŸŸ¡' };

            for (const comment of inlineComments) {
              const position = findDiffPosition(comment.file, comment.line);
              if (position && filePatches[comment.file]) {
                const emoji = severityEmoji[comment.severity] || 'ðŸ’¬';
                reviewComments.push({
                  path: comment.file,
                  position: position,
                  body: `${emoji} **${(comment.severity || 'comment').toUpperCase()}**\n\n${comment.comment}`
                });
              }
            }

            const hasCritical = inlineComments.some(c => c.severity === 'critical');
            const reviewEvent = hasCritical ? 'REQUEST_CHANGES' : 'COMMENT';

            const summaryBody = `## ðŸ¤– AI Code Review

            ${summary}

            ---
            *Automated review powered by Gemini AI â€¢ ${reviewComments.length} inline comments added*`;

            try {
              if (reviewComments.length > 0) {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  body: summaryBody,
                  event: reviewEvent,
                  comments: reviewComments
                });
                console.log('Created review with ' + reviewComments.length + ' inline comments');
              } else {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  body: summaryBody,
                  event: 'COMMENT'
                });
                console.log('Created review without inline comments');
              }
            } catch (error) {
              console.error('Error creating review:', error.message);
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: summaryBody
              });
            }
