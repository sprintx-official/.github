# =============================================================================
# ORGANIZATION REUSABLE WORKFLOW - AI PR Review (Senior Developer Level)
# =============================================================================
# Intelligent code review that understands your project context, detects
# code reuse opportunities, and reviews like a senior developer would.
#
# Individual repos can call this workflow with just a few lines:
#
# jobs:
#   review:
#     uses: sprintx-official/.github/.github/workflows/pr-review.yml@main
#     secrets: inherit
# =============================================================================

name: ZOBI PR Review

on:
  workflow_call:
    inputs:
      conventions_path:
        description: 'Path to conventions file'
        required: false
        type: string
        default: '.planning/CONVENTIONS.md'
      project_standards_path:
        description: 'Path to project standards file'
        required: false
        type: string
        default: '.planning/PROJECT.md'
      project_docs_path:
        description: 'Path to project documentation (idea, features, requirements)'
        required: false
        type: string
        default: 'docs/PROJECT.md'
      model:
        description: 'Gemini model to use'
        required: false
        type: string
        default: 'gemini-2.0-flash'
      max_diff_size:
        description: 'Maximum diff size to send to AI (in characters)'
        required: false
        type: number
        default: 50000
      scan_patterns:
        description: 'JSON array of glob patterns to scan for existing code (e.g., ["src/components/**/*.tsx", "src/utils/**/*.ts"])'
        required: false
        type: string
        default: '["src/components/**/*", "src/lib/**/*", "src/utils/**/*", "src/helpers/**/*", "src/hooks/**/*", "src/constants/**/*", "src/shared/**/*", "lib/**/*", "utils/**/*", "common/**/*"]'
      dev_profiles_repo:
        description: 'Private repo for developer profiles (org/repo format)'
        required: false
        type: string
        default: 'sprintx-official/dev-profiles'
    secrets:
      GEMINI_API_KEY:
        required: true
      DEV_PROFILES_PAT:
        required: false
      ZOBI_REVIEW_PROMPT:
        description: 'Review prompt template with placeholders'
        required: true

permissions:
  contents: read
  pull-requests: write

jobs:
  ai-review:
    runs-on: ubuntu-latest
    name: ZOBI PR Review
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Checkout developer profiles
        id: checkout-profiles
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.dev_profiles_repo }}
          token: ${{ secrets.DEV_PROFILES_PAT }}
          path: dev-profiles
          persist-credentials: true

      - name: Read developer profile
        id: dev-profile
        run: |
          AUTHOR="${{ github.event.pull_request.user.login }}"
          REPO_NAME="${{ github.event.repository.name }}"
          PR_NUMBER="${{ github.event.pull_request.number }}"
          echo "author=${AUTHOR}" >> $GITHUB_OUTPUT
          echo "repo=${REPO_NAME}" >> $GITHUB_OUTPUT
          echo "pr_number=${PR_NUMBER}" >> $GITHUB_OUTPUT

          PROFILE_PATH="dev-profiles/devs/${AUTHOR}.md"
          if [ -f "$PROFILE_PATH" ]; then
            echo "Found existing profile for ${AUTHOR}"
            cat "$PROFILE_PATH" > dev_profile.txt

            # Check if this PR was already reviewed (to avoid incrementing count)
            if grep -q "PR #${PR_NUMBER} (${REPO_NAME})" "$PROFILE_PATH"; then
              echo "pr_already_reviewed=true" >> $GITHUB_OUTPUT
              echo "This PR (#${PR_NUMBER}) was already reviewed - will not increment count"
            else
              echo "pr_already_reviewed=false" >> $GITHUB_OUTPUT
              echo "First review for PR #${PR_NUMBER}"
            fi
          else
            echo "Creating new profile template for ${AUTHOR}"
            echo "pr_already_reviewed=false" >> $GITHUB_OUTPUT
            cat > dev_profile.txt << EOF
          # Developer Profile: ${AUTHOR}

          ## Stats
          - **Total PRs Reviewed:** 0
          - **Last Review:** Never
          - **Repositories:** None yet

          ## Reviewed PRs
          <!-- Tracks which PRs have been reviewed to avoid duplicate counting -->

          ## Strengths
          (To be discovered through code reviews)

          ## Areas for Improvement
          (To be discovered through code reviews)

          ## Recent Feedback History
          | Date | Repo | Category | Issue Summary |
          |------|------|----------|---------------|

          ## AI Learning Notes
          <!-- Patterns the AI has observed -->
          - New developer, building profile...
          EOF
          fi

      - name: Get PR diff
        id: diff
        run: |
          AUTHOR="${{ steps.dev-profile.outputs.author }}"
          PR_NUMBER="${{ steps.dev-profile.outputs.pr_number }}"
          REPO_NAME="${{ steps.dev-profile.outputs.repo }}"
          PROFILE_PATH="dev-profiles/devs/${AUTHOR}.md"

          # Check if we have a last reviewed commit for this PR
          LAST_REVIEWED_COMMIT=""
          if [ -f "$PROFILE_PATH" ]; then
            # Extract last reviewed commit for this specific PR
            LAST_REVIEWED_COMMIT=$(grep "PR #${PR_NUMBER} (${REPO_NAME})" "$PROFILE_PATH" | tail -1 | grep -oE '[a-f0-9]{40}' | head -1 || true)
          fi

          if [ -n "$LAST_REVIEWED_COMMIT" ]; then
            echo "Found previous review at commit: ${LAST_REVIEWED_COMMIT}"
            echo "Getting incremental diff since last review..."
            echo "is_incremental=true" >> $GITHUB_OUTPUT
            echo "last_commit=${LAST_REVIEWED_COMMIT}" >> $GITHUB_OUTPUT

            # Get diff only for new commits since last review
            git diff ${LAST_REVIEWED_COMMIT}...origin/${{ github.head_ref }} > pr_diff.txt
            git diff --name-only ${LAST_REVIEWED_COMMIT}...origin/${{ github.head_ref }} > changed_files.txt

            # Get list of new commits for context
            echo "New commits since last review:" > new_commits.txt
            git log --oneline ${LAST_REVIEWED_COMMIT}...origin/${{ github.head_ref }} >> new_commits.txt
          else
            echo "First review for this PR - getting full diff"
            echo "is_incremental=false" >> $GITHUB_OUTPUT

            git diff origin/${{ github.base_ref }}...origin/${{ github.head_ref }} > pr_diff.txt
            git diff --name-only origin/${{ github.base_ref }}...origin/${{ github.head_ref }} > changed_files.txt
            echo "Full PR review" > new_commits.txt
          fi

          # Save current commit SHA for tracking
          CURRENT_COMMIT=$(git rev-parse origin/${{ github.head_ref }})
          echo "current_commit=${CURRENT_COMMIT}" >> $GITHUB_OUTPUT

          echo "Changed files:"
          cat changed_files.txt

      - name: Read project files
        run: |
          # Read conventions
          if [ -f "${{ inputs.conventions_path }}" ]; then
            cat "${{ inputs.conventions_path }}" > conventions_content.txt
          else
            echo "No conventions file found" > conventions_content.txt
          fi

          # Read project standards
          if [ -f "${{ inputs.project_standards_path }}" ]; then
            cat "${{ inputs.project_standards_path }}" > standards_content.txt
          else
            echo "No project standards file found" > standards_content.txt
          fi

          # Read project documentation (idea, features, requirements)
          if [ -f "${{ inputs.project_docs_path }}" ]; then
            cat "${{ inputs.project_docs_path }}" > project_docs_content.txt
          else
            echo "No project documentation file found" > project_docs_content.txt
          fi

      - name: Scan existing codebase for reusable patterns
        run: |
          echo "=== EXISTING CODEBASE ANALYSIS ===" > codebase_context.txt
          echo "" >> codebase_context.txt

          # Parse scan patterns from input
          PATTERNS='${{ inputs.scan_patterns }}'

          # Find and list all existing components, utils, helpers, hooks, constants
          echo "### Existing Reusable Code Files ###" >> codebase_context.txt
          echo "These are files that contain potentially reusable code. Check if the PR duplicates any of these." >> codebase_context.txt
          echo "" >> codebase_context.txt

          # Find files matching patterns and extract their exports/definitions
          for pattern in $(echo "$PATTERNS" | jq -r '.[]' 2>/dev/null || echo "src/components src/utils src/lib src/helpers src/hooks src/constants"); do
            if ls $pattern 2>/dev/null | head -1 > /dev/null; then
              echo "#### Pattern: $pattern ####" >> codebase_context.txt
              find . -path "./$pattern" -type f \( -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" \) 2>/dev/null | head -100 | while read file; do
                if [ -f "$file" ]; then
                  echo "" >> codebase_context.txt
                  echo "**File: $file**" >> codebase_context.txt
                  # Extract exports, function names, component names, constants
                  grep -E "^export (const|function|class|interface|type|enum|default)" "$file" 2>/dev/null | head -20 >> codebase_context.txt || true
                  grep -E "^(const|let|var) [A-Z][A-Z_]+ =" "$file" 2>/dev/null | head -10 >> codebase_context.txt || true
                fi
              done
              echo "" >> codebase_context.txt
            fi
          done

          # Analyze common patterns in the codebase
          echo "" >> codebase_context.txt
          echo "### Common Patterns Detected ###" >> codebase_context.txt

          # Find commonly used custom hooks
          echo "" >> codebase_context.txt
          echo "#### Custom Hooks Available ####" >> codebase_context.txt
          find . -type f -name "use*.ts" -o -name "use*.tsx" 2>/dev/null | grep -v node_modules | grep -v ".next" | head -30 >> codebase_context.txt || echo "None found" >> codebase_context.txt

          # Find utility functions
          echo "" >> codebase_context.txt
          echo "#### Utility Files ####" >> codebase_context.txt
          find . -type f \( -path "*/utils/*" -o -path "*/helpers/*" -o -path "*/lib/*" \) \( -name "*.ts" -o -name "*.js" \) 2>/dev/null | grep -v node_modules | grep -v ".next" | head -30 >> codebase_context.txt || echo "None found" >> codebase_context.txt

          # Find constants files
          echo "" >> codebase_context.txt
          echo "#### Constants Files ####" >> codebase_context.txt
          find . -type f \( -path "*/constants/*" -o -name "constants.ts" -o -name "constants.js" -o -name "config.ts" -o -name "config.js" \) 2>/dev/null | grep -v node_modules | grep -v ".next" | head -20 >> codebase_context.txt || echo "None found" >> codebase_context.txt

          # Find shared/common components
          echo "" >> codebase_context.txt
          echo "#### Shared/Common Components ####" >> codebase_context.txt
          find . -type f \( -path "*/components/common/*" -o -path "*/components/shared/*" -o -path "*/components/ui/*" \) \( -name "*.tsx" -o -name "*.jsx" \) 2>/dev/null | grep -v node_modules | grep -v ".next" | head -30 >> codebase_context.txt || echo "None found" >> codebase_context.txt

          # Truncate if too large
          if [ $(wc -c < codebase_context.txt) -gt 30000 ]; then
            head -c 30000 codebase_context.txt > codebase_context_truncated.txt
            mv codebase_context_truncated.txt codebase_context.txt
            echo "" >> codebase_context.txt
            echo "... (truncated for size)" >> codebase_context.txt
          fi

          echo "Codebase context generated successfully"
          cat codebase_context.txt

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Save prompt from secret
        env:
          ZOBI_REVIEW_PROMPT: ${{ secrets.ZOBI_REVIEW_PROMPT }}
        run: |
          if [ -z "$ZOBI_REVIEW_PROMPT" ]; then
            echo "ERROR: ZOBI_REVIEW_PROMPT secret is required but not set"
            exit 1
          fi
          echo "Loading review prompt from ZOBI_REVIEW_PROMPT secret"
          echo "$ZOBI_REVIEW_PROMPT" > prompt_template.txt

      - name: Create review script
        run: |
          cat > review_script.cjs << 'SCRIPT_EOF'
          const fs = require('fs');
          const https = require('https');

          // Read prompt template (required)
          if (!fs.existsSync('prompt_template.txt')) {
            console.error('ERROR: prompt_template.txt not found. ZOBI_REVIEW_PROMPT secret is required.');
            process.exit(1);
          }
          const promptTemplate = fs.readFileSync('prompt_template.txt', 'utf8');

          const maxDiffSize = parseInt(process.env.MAX_DIFF_SIZE || '50000');
          const diff = fs.readFileSync('pr_diff.txt', 'utf8').slice(0, maxDiffSize);
          const changedFiles = fs.readFileSync('changed_files.txt', 'utf8');
          const conventions = fs.readFileSync('conventions_content.txt', 'utf8');
          const standards = fs.readFileSync('standards_content.txt', 'utf8');
          const projectDocs = fs.readFileSync('project_docs_content.txt', 'utf8');
          const codebaseContext = fs.readFileSync('codebase_context.txt', 'utf8');
          const developerProfile = fs.existsSync('dev_profile.txt') ? fs.readFileSync('dev_profile.txt', 'utf8') : 'No developer profile available';
          const newCommits = fs.existsSync('new_commits.txt') ? fs.readFileSync('new_commits.txt', 'utf8') : '';
          const prTitle = process.env.PR_TITLE || 'No title';
          const prBody = process.env.PR_BODY || 'No description';
          const prAuthor = process.env.PR_AUTHOR || 'unknown';
          const repoName = process.env.REPO_NAME || 'unknown';
          const prNumber = process.env.PR_NUMBER || '0';
          const currentCommit = process.env.CURRENT_COMMIT || 'unknown';
          const isIncremental = process.env.IS_INCREMENTAL === 'true';
          const prAlreadyReviewed = process.env.PR_ALREADY_REVIEWED === 'true';
          const model = process.env.GEMINI_MODEL || 'gemini-2.0-flash';
          const today = process.env.REVIEW_DATE || new Date().toISOString().split('T')[0];

          // Replace all placeholders in prompt template
          const prompt = promptTemplate
            .replace(/\{\{projectDocs\}\}/g, projectDocs)
            .replace(/\{\{standards\}\}/g, standards)
            .replace(/\{\{conventions\}\}/g, conventions)
            .replace(/\{\{codebaseContext\}\}/g, codebaseContext)
            .replace(/\{\{developerProfile\}\}/g, developerProfile)
            .replace(/\{\{prAuthor\}\}/g, prAuthor)
            .replace(/\{\{repoName\}\}/g, repoName)
            .replace(/\{\{prNumber\}\}/g, prNumber)
            .replace(/\{\{prTitle\}\}/g, prTitle)
            .replace(/\{\{prBody\}\}/g, prBody)
            .replace(/\{\{changedFiles\}\}/g, changedFiles)
            .replace(/\{\{diff\}\}/g, diff)
            .replace(/\{\{today\}\}/g, today)
            .replace(/\{\{currentCommit\}\}/g, currentCommit)
            .replace(/\{\{isIncremental\}\}/g, String(isIncremental))
            .replace(/\{\{newCommits\}\}/g, newCommits)
            .replace(/\{\{prAlreadyReviewed\}\}/g, String(prAlreadyReviewed));

          console.log('Prompt loaded from ZOBI_REVIEW_PROMPT secret');

          const requestBody = JSON.stringify({
            contents: [{ parts: [{ text: prompt }] }],
            generationConfig: {
              temperature: 0.3,
              topK: 40,
              topP: 0.95,
              maxOutputTokens: 8192
            }
          });

          const options = {
            hostname: 'generativelanguage.googleapis.com',
            path: `/v1beta/models/${model}:generateContent?key=${process.env.GEMINI_API_KEY}`,
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Content-Length': Buffer.byteLength(requestBody)
            }
          };

          const req = https.request(options, (res) => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
              try {
                const json = JSON.parse(data);
                if (json.candidates && json.candidates[0] && json.candidates[0].content) {
                  fs.writeFileSync('review_output.txt', json.candidates[0].content.parts[0].text);
                  console.log('Review generated successfully');
                } else if (json.error) {
                  fs.writeFileSync('review_output.txt', 'API Error: ' + json.error.message);
                  console.error('API Error:', json.error.message);
                } else {
                  fs.writeFileSync('review_output.txt', 'Unexpected response format from Gemini API');
                  console.error('Unexpected response:', data);
                }
              } catch (e) {
                fs.writeFileSync('review_output.txt', 'Parse error: ' + e.message);
                console.error('Parse error:', e.message);
              }
            });
          });

          req.on('error', (e) => {
            fs.writeFileSync('review_output.txt', 'Request error: ' + e.message);
            console.error('Request error:', e.message);
          });

          req.write(requestBody);
          req.end();
          SCRIPT_EOF

      - name: Run Gemini PR Review
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_BODY: ${{ github.event.pull_request.body }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_AUTHOR: ${{ steps.dev-profile.outputs.author }}
          REPO_NAME: ${{ steps.dev-profile.outputs.repo }}
          GEMINI_MODEL: ${{ inputs.model }}
          MAX_DIFF_SIZE: ${{ inputs.max_diff_size }}
          CURRENT_COMMIT: ${{ steps.diff.outputs.current_commit }}
          IS_INCREMENTAL: ${{ steps.diff.outputs.is_incremental }}
          PR_ALREADY_REVIEWED: ${{ steps.dev-profile.outputs.pr_already_reviewed }}
          # Use UTC date to ensure consistent dates across all runners
          REVIEW_DATE: ${{ github.event.pull_request.updated_at && format('{0}', github.event.pull_request.updated_at) || '' }}
        run: |
          # Set proper date (GitHub Actions runners are UTC)
          export REVIEW_DATE=$(date -u +%Y-%m-%d)
          node review_script.cjs

      - name: Post review with inline comments
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const reviewOutput = fs.readFileSync('review_output.txt', 'utf8');

            let inlineComments = [];
            let summary = reviewOutput;

            try {
              const jsonMatch = reviewOutput.match(/```json\n?([\s\S]*?)\n?```/);
              if (jsonMatch) {
                inlineComments = JSON.parse(jsonMatch[1]);
                summary = reviewOutput.replace(/```json\n?[\s\S]*?\n?```/, '').trim();
              } else {
                const arrayMatch = reviewOutput.match(/\[\s*\{[\s\S]*?\}\s*\]/);
                if (arrayMatch) {
                  inlineComments = JSON.parse(arrayMatch[0]);
                  summary = reviewOutput.replace(arrayMatch[0], '').trim();
                }
              }
              // Remove the developer profile section from the summary (it's saved separately)
              summary = summary.replace(/```developer-profile[\s\S]*?```/g, '').trim();
              // Also remove the "PART 3" header if present
              summary = summary.replace(/---\s*\n*##\s*PART 3:.*$/s, '').trim();
            } catch (e) {
              console.log('Could not parse inline comments:', e.message);
            }

            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            const filePatches = {};
            for (const file of files) {
              filePatches[file.filename] = file.patch || '';
            }

            function findDiffPosition(filename, targetLine) {
              const patch = filePatches[filename];
              if (!patch) return null;

              const lines = patch.split('\n');
              let currentLine = 0;
              let position = 0;

              for (const line of lines) {
                position++;
                const hunkMatch = line.match(/@@ -\d+(?:,\d+)? \+(\d+)(?:,\d+)? @@/);
                if (hunkMatch) {
                  currentLine = parseInt(hunkMatch[1]) - 1;
                  continue;
                }
                if (line.startsWith('-')) {
                  continue;
                }
                if (line.startsWith('+') || !line.startsWith('-')) {
                  currentLine++;
                  if (currentLine === targetLine) {
                    return position;
                  }
                }
              }
              return null;
            }

            const reviewComments = [];
            const severityEmoji = { critical: 'ðŸ”´', warning: 'ðŸŸ ', suggestion: 'ðŸŸ¡' };
            const categoryEmoji = {
              'reuse': 'â™»ï¸',
              'architecture': 'ðŸ—ï¸',
              'future-problem': 'âš ï¸',
              'quality': 'ðŸ“–',
              'security': 'ðŸ”’',
              'performance': 'âš¡',
              'alignment': 'ðŸŽ¯'
            };
            const categoryLabel = {
              'reuse': 'Code Reuse',
              'architecture': 'Architecture',
              'future-problem': 'Future Problem',
              'quality': 'Code Quality',
              'security': 'Security',
              'performance': 'Performance',
              'alignment': 'Project Alignment'
            };

            for (const comment of inlineComments) {
              const position = findDiffPosition(comment.file, comment.line);
              if (position && filePatches[comment.file]) {
                const sevEmoji = severityEmoji[comment.severity] || 'ðŸ’¬';
                const catEmoji = categoryEmoji[comment.category] || '';
                const catLabel = categoryLabel[comment.category] || '';
                const categoryTag = catLabel ? ` \`${catLabel}\`` : '';

                reviewComments.push({
                  path: comment.file,
                  position: position,
                  body: `${sevEmoji} **${(comment.severity || 'comment').toUpperCase()}**${categoryTag}\n\n${catEmoji} ${comment.comment}`
                });
              }
            }

            // Count issues by category for summary
            const categoryCounts = {};
            for (const comment of inlineComments) {
              const cat = comment.category || 'other';
              categoryCounts[cat] = (categoryCounts[cat] || 0) + 1;
            }

            const hasCritical = inlineComments.some(c => c.severity === 'critical');
            const hasWarning = inlineComments.some(c => c.severity === 'warning');
            const reviewEvent = hasCritical ? 'REQUEST_CHANGES' : 'COMMENT';

            // Build category breakdown
            let categoryBreakdown = '';
            if (Object.keys(categoryCounts).length > 0) {
              categoryBreakdown = '\n\n**Issues by Category:**\n';
              for (const [cat, count] of Object.entries(categoryCounts)) {
                const emoji = categoryEmoji[cat] || 'ðŸ“';
                const label = categoryLabel[cat] || cat;
                categoryBreakdown += `- ${emoji} ${label}: ${count}\n`;
              }
            }

            const summaryBody = `## ðŸ¤– ZOBI Review\n\n${summary}\n${categoryBreakdown}\n---\n*Reviewed by ZOBI (Senior AI Code Reviewer) â€¢ ${reviewComments.length} inline comments â€¢ ${hasCritical ? 'ðŸ”´ Has critical issues' : hasWarning ? 'ðŸŸ  Has warnings' : 'âœ… Looks good'}*`;

            try {
              if (reviewComments.length > 0) {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  body: summaryBody,
                  event: reviewEvent,
                  comments: reviewComments
                });
                console.log('Created review with ' + reviewComments.length + ' inline comments');
              } else {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  body: summaryBody,
                  event: 'COMMENT'
                });
                console.log('Created review without inline comments');
              }
            } catch (error) {
              console.error('Error creating review:', error.message);
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: summaryBody
              });
            }

      - name: Extract and save developer profile
        if: steps.checkout-profiles.outcome == 'success'
        run: |
          AUTHOR="${{ steps.dev-profile.outputs.author }}"

          echo "=== DEBUG: Checking profile extraction ==="
          echo "Author: ${AUTHOR}"
          echo "Checkout outcome: ${{ steps.checkout-profiles.outcome }}"

          if [ ! -f "review_output.txt" ]; then
            echo "ERROR: review_output.txt not found!"
            exit 1
          fi

          REVIEW_OUTPUT=$(cat review_output.txt)
          echo "Review output length: ${#REVIEW_OUTPUT}"

          # Extract developer profile from the output
          PROFILE=$(echo "$REVIEW_OUTPUT" | sed -n '/```developer-profile/,/```/p' | sed '1d;$d')

          echo "Extracted profile length: ${#PROFILE}"

          if [ -n "$PROFILE" ]; then
            echo "âœ“ Extracted developer profile for ${AUTHOR}"
            mkdir -p dev-profiles/devs
            echo "$PROFILE" > "dev-profiles/devs/${AUTHOR}.md"
            echo "âœ“ Profile saved to dev-profiles/devs/${AUTHOR}.md"
            echo "Profile content preview:"
            head -n 5 "dev-profiles/devs/${AUTHOR}.md"
          else
            echo "âš  No developer profile found in output"
            echo "Searching for profile markers in output..."
            grep -n "developer-profile" review_output.txt || echo "No 'developer-profile' marker found"
            grep -n "PART 3" review_output.txt || echo "No 'PART 3' marker found"
          fi

      - name: Push updated developer profile
        if: steps.checkout-profiles.outcome == 'success'
        run: |
          AUTHOR="${{ steps.dev-profile.outputs.author }}"
          PROFILE_PATH="dev-profiles/devs/${AUTHOR}.md"

          echo "=== DEBUG: Pushing profile ==="
          echo "Profile path: ${PROFILE_PATH}"
          echo "File exists: $([ -f "$PROFILE_PATH" ] && echo 'YES' || echo 'NO')"

          if [ -f "$PROFILE_PATH" ]; then
            echo "âœ“ Profile file found"
            cd dev-profiles

            # Check if devs folder exists in repo
            if [ ! -d "devs" ]; then
              echo "Creating devs directory"
              mkdir -p devs
            fi

            # Copy profile to devs folder (may already be there from extract step)
            cp "../${PROFILE_PATH}" "devs/${AUTHOR}.md" 2>/dev/null || true

            git config user.name "ZOBI Review"
            git config user.email "zobi-review@sprintx.com"
            git add devs/

            echo "Git status:"
            git status

            # Only commit if there are changes
            if git diff --staged --quiet; then
              echo "âš  No changes to developer profile"
            else
              echo "âœ“ Changes detected, committing..."
              git commit -m "ZOBI: Update profile for ${AUTHOR} - $(date -u +%Y-%m-%d)"
              echo "âœ“ Pushing to remote..."
              git push
              echo "âœ“ Successfully pushed updated profile for ${AUTHOR}"
            fi
          else
            echo "âš  No profile file found at ${PROFILE_PATH}"
            echo "Listing dev-profiles directory:"
            ls -la dev-profiles/ || echo "dev-profiles directory not found"
          fi
        continue-on-error: true
